# many tricks
# https://stackoverflow.com/questions/53136024/makefile-to-compile-all-c-files-without-needing-to-specify-them
# https://accu.org/journals/overload/14/71/miller_2004/ famous paper: recursive make considered harmful

# debug option, override with make all debug=no CFLAGS=-std=c99
# yes, use in code of JMMJ_DEBUG (example in main.c), and -g four building in debug mode( possibility to use a debugger)
# no, compile with optimization -O2
debug = yes
#debug = no

# compilers, may give different errors/warning
CC = gcc
#CC = clang

# List of subdirectories containing a Module.mk file
#MODULES := tests tests/test_mock
# clogger call by an explicit make, no use of module
MODULES := ccontainer joueur record game_loader tests

# see advices (and much more than compilation options) https://matt.sh/howto-c
# compiler option, activate many warning( here seeems common to gcc and clang)
# pedantic => -Wpedantic gcc new
# -fno-inline ? 
# -Wno-unused-local-typedefs no need
# -Wstrict-overflow=5, make pass game_morpion compilation
# -Wunused -W (included already)
# -fPIC on Windows, not adviced ?
#       on linux not for performance ? but cannot comile, give error !
# -g3 : all debug information + MACRO (-g0 : no debug ), -g default 2
# -ggdb : include gdb extension if possible (not tested)
# add include path current
CFLAGS = -Wall -Wextra -pedantic -Wno-variadic-macros -I . #-Wno-strict-overflow
# to include again:  -Werror, better than Wno-X warning appears but compiles fine

# standard configurable
# gcc c89/90 : -ansi, -std=c90 or -std=iso9899:1990
STD = -std=c90

# standard gcc defines usually NDEBUG for release code (assert.h affected)
# code uses internally a JMMJ_DEBUG, defined in preprocessor stage 
# 	or declare directly here ? better will apply to all files without need to include a common header ?
ifeq ($(debug),yes)          # separator mandatory between ifeq and '('
# use specific code for the project, g3 to include MACRO definition as variables
	CFLAGS += -g3 -O0 -DJMMJ_DEBUG
else
# kind of standard with gcc projects
	CFLAGS += -DNDEBUG -O2
endif

# search for all *.c files and make *.o files
# keep for example
#SRCS := $(wildcard *.c)
#OBJS := $(patsubst %.c, %.o, $(SRCS))
# take away main.o to avoid mutliple main() functions
#OBJS := $(filter-out main.o, $(OBJS))

# Use explicit OBJS, more control
# do not include main.o
# replace step-by-step by library : 
# 	clogger : clogger.o,
#   ccontainer : clist_generic.o clist_cstring.o
#   record : irecord.o file_record.o
#   joueur :cmap_game_victories.o person.o joueur.o # victory ?? only header ??
#		then include victory.o
#   game_loader : plugin_manager.o cmap_ptrf_game.o game_loader.o
OBJS = utils.o utils_file.o arcade.o
	   

OBJS_CORE += $(OBJS)

# define main executable
EXE  := JMMjouer

# inspect variables
$(info == ROOT ==)
$(info $$OBJS is [$(OBJS)] )
$(info $$OBJS is [$(OBJS_CORE)] )

STD_TESTS = -std=c99

# alternative to target as files
#.PHONY : all clean unit_test
.PHONY : dep_lib
dep_lib : libclogger.a libccontainer.a libjoueur.dll librecord.dll libgame_pendu.dll

# make all, generic way to use make produce executable JMMjouer
all: $(EXE)
# specific target for unit testing in tests/ , dependencies with CMocka
unit_test::
# unit_test_mock::

# general rule for compiling c files when header file is available 
%.o: %.c %.h
	@echo "Build file generic rule with header in root:   $@"
	$(CC) $(STD) $(CFLAGS) -c $< -o $@

# general rule, no header file associated (ex. main.c)
%.o: %.c
	@echo "Build file generic rule without header in root:   $@"
	$(CC) $(STD) $(CFLAGS) -c $< -o $@

# include the description for each module
include $(patsubst %,%/Module.mingw64_gcc.mk,$(MODULES))

# intermediate library, victory not needed ??
# here or in own module... best ??
#libjoueur.dll : person.o joueur.o cmap_game_victories.o libclogger.a
#	$(CC) -shared $(CFLAGS) -o $@ $^ -L. -lccontainer -Wl,--out-implib,libjoueur.lib

# -Wl,-rpath,dir1  or -rpath=dir1 # -Wl to pass argument to linker, rpath runtime to search for lib
#$(EXE): $(OBJS) main.o libclogger.a libccontainer.a librecord.a libgame_pendu.dll
#	@echo "Build $(EXE): all dependencies $^" \
#	$(CC) $(STD) $(CFLAGS) $^ -L. -lgame_pendu -o $@

$(info)
$(info == ROOT 2 ==)
$(info $$OBJS is [$(OBJS)] )
$(info $$OBJS_CORE is [$(OBJS_CORE)] )
$(info $$OBJS_GM is [$(OBJS_GM)] )
$(info dir: $(dir $(lastword $(MAKEFILE_LIST))) )

# seems very convenient !
currentDir = $(dir $(lastword $(MAKEFILE_LIST)))

# libgame_loader.dll 
# libjoueur_dll.lib
#$(EXE): $(OBJS_CORE) $(OBJS_GM) main.o libgame_pendu.dll libclogger.a libccontainer.a librecord.dll
#	@echo "Build $(EXE): all dependencies $^"
#	@echo "Build with OBJS_CORE $(OBJS_CORE)"
# libcontainer not present, already included lrecord, otherwise double definition
# indeed it was already in the list $^
#	$(CC) $(STD) $(CFLAGS) -o $@ $^ -L. -lgame_pendu -ljoueur_dll -lrecord 

# with libgame_loader.dll (exporting all symbols)
# ok, do not care of multiple definitions
#$(EXE): main.o arcade.o libgame_loader.dll libclogger.a libccontainer.a librecord.dll
#	@echo "Build $(EXE): all dependencies $^"
#	@echo "Build with OBJS_CORE $(OBJS_CORE)"
#	$(CC) $(STD) $(CFLAGS) $(OBJS) main.o -L. -lgame_pendu -ljoueur -lrecord -o $@
# libcontainer not present, already included lrecord, otherwise double definition
# indeed it was already in the list $^
#	$(CC) $(STD) $(CFLAGS) -o $@ $^ -L. -lgame_pendu -ljoueur_dll -lrecord
# yep working, but all in libgame_loader ! 
#	

# with libgame_loader as static
$(EXE): main.o $(OBJS) libgame_loader.lib libclogger.a libccontainer.a librecord.dll
	@echo "Build $(EXE): all dependencies $^"
	@echo "Build with OBJS_CORE $(OBJS_CORE)"	
	$(CC) $(STD) $(CFLAGS) -o $@ $^ -L. -ljoueur_dll

# working
#gcc -std=c90 -Wall -Wextra -pedantic -Wno-variadic-macros -I .  -g3 -O0 -DJMMJ_DEBUG -o JMMjouer \
#	utils.o utils_file.o game_mastermind.o arcade.o main.o \
#	game_loader/cmap_ptrf_game.o game_loader/plugin_manager.o game_loader/game_loader.o \
#	libgame_pendu.dll libclogger.a libccontainer.a libjoueur.dll librecord.dll -L. -lgame_pendu -ljoueur -lrecord

## Version full static
JMMjouer_static : main.o $(OBJS) $(OBJS_CCONTAINER) $(OBJS_JOUEUR) $(OBJS_GAME_LOADER) $(OBJS_RECORD) clogger/clogger.o
	$(CC) $(STD) $(CFLAGS) -o $@ $^


#### libraries in dependencies,
## usefull to copy ? or better to include in a common path (e.g. for TU ?)
libclogger.a : 
	cd clogger && make -f Makefile.mingw64_gcc libclogger.a
	cp clogger/libclogger.a .
	
# test with module, target will be included
#libccontainer.a :
#	cd ccontainer && make -f Makefile.mingw64_gcc libccontainer.a
# librecord.dll


##### compile shared library to include at run-time (game_morpion)
# version unix-like available more recently in mingw
#libmorpion.dll : game_morpion.o game_morpion.h
#	$(CC) -shared game_morpion.o -o libmorpion.dll

# windows style, with importing lib, not used at run-time link anyway
# if no joueur/victory.o => undefined victory_init
# can include joueur/victory.o (already in libjoueur)
#libgame_morpion.dll : game_morpion.o game_morpion.h joueur/victory.o
#	$(CC) -shared $(CFLAGS) $^ -o $@ -Wl,--out-implib,libgame_morpion.lib
# link to libjoueur throught libjoueur.lib , fine also
libgame_morpion.dll : game_morpion.o game_morpion.h
	$(CC) -shared $(CFLAGS) -o $@ $^ -L. -ljoueur_dll -Wl,--out-implib,libgame_morpion_dll.lib

# call clean here and in subdirectories
clean::
	@echo "Clean in root directory"
	cd clogger && make -f Makefile.mingw64_gcc clean
	rm -f ./*.o
	rm -f ./*.dll ./*.lib ./*.a
	rm -f JMMjouer JMMjouer_static
# should not be here
	rm -f test*.exe
